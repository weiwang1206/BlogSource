# IO多路复用

什么是IO多路复用？以网络程序为例，当我们对一个socket进行读操作，我们可以使用阻塞的方式对这个socket进行读操作(read)，然而当我们有多个socket需要读时，怎么办呢（这种情况非常普遍，例如网络服务器，需要对成千上万的客户端进行服务和应答，需要同时处理这些socket）？一种方法是简单地进行循环操作，当一个socket读取完成后，再读取下一个socket就行了，Yes！听起来很好，但是，当我们读取一个socket时，如果发生阻塞（需要读取的数据还没来），程序就会停在这里，从而影响读取其他socket。那是不是把socket设置成非阻塞在进行轮训是不是就不会因为一个socket阻塞而影响其他socket了呢，答案是肯定的。但是这样效率非常低，代码看起来像是这样

	while(true)
	{
		for(int i = 0; i < fdSize; i++)
		{
			int n = read(fd[i],buf,bufSize); //fd is non_block
			//handle the message
		}
	}
这种方法轮训所有的socket数组，然后反复尝试读取，看是否有新的可读的数据，这样的方式是非常低效的。还有一种稍微高效点的方式是采用多线程，针对每个socket启动一个线程来进行处理，这样每个socket互补影响，而且都可以得到及时的响应。但缺点也是显而易见的，就是当客户端连接非常多的时候，系统创建的线程也非常多，线程也是消耗CPU和内存的，线程的切换也非常耗时，系统的处理能力会明显降低。

然而，如果内核能告诉我们哪些socket有数据可读（或可写），我们就直接去读取那个socket是不是就能高效了呢？是的，这就是**IO多路复用**的用处。IO多路复用也经过了较长时间的优化，从最开始的select到poll，再到epoll和FreeBSD的kqueue。本系列博客将分别介绍这些IO多路复用技术，及其相关的一些知识，目录如下

- [阻塞与非阻塞，同步与非同步]()

- [select](http://)

- [poll](http://)

- [epoll](http://)

- [kqueue](http://)

- [边缘触发和水平触发](http://)
